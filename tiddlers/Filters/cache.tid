title: Cache Filter Run Prefix
tags: [[Filter Run Prefixes]] Filters
caption: :cache

|!purpose |caches run in order to improve performance |
|!input |the filter output of all previous runs so far |
|!output |the combined output of the run executed with each input as currentTiddler |

<$railroad text="""
\start none
\end none
( ":cache" | - )
[[run|"Filter Run"]]
""" />

This advanced prefix is executed as a generator run only, meaning the run is not passed the input from previous runs. However, for each input, the generate run is execute with that input with the <<.var currentTiddler>> variable set to the title of the input tiddler. The output of all executions of the run are combined and dominantely appended.

The output generated by this run is cached internally, and if the exact same filter string is run again, that cached data is returned. This cache refreshes whenever the wiki changes.

<<.value :cache>> keeps track of variables that are requested from inside its run and maintains separate cache instances for each combination of those variables.

Because of how frequently <<.value currentTiddler>> is invoked, it's assigned to the value of each input of the previous runs, or nothing if there is no input from previous runs.

The reason for restricting variable access within the run is to improve cache performance. Every combination of variables could result in different run output, and thus every combination must be run independently. <<.value currentTiddler>> is especially prone to being called frequently by various TW elements, even when it's not needed, thus may accidentally ruin the cache's performance if it's used in a loop where <<.value currentTiddler>> inadvertently changes with each pass.

If you want to use the actual <<.value currentTiddler>> in a cache run, just pass it explicitly like this: `[<currentTiddler>] :cache[...]`.

!! Advice on using :cache

The cache prefix takes a little know-how to use //effectively//. It's important to realize that while it //can// execute filter runs that require variables, ''the more changing variables the internal run calls, the less effective the cache becomes''. This is because it must cache each output uniquely based on the values of all used variables.

For instance, let's take an example used within <<.graph>>. It needs to access all edge types of a certain category (such as <<.value fields>> or <<.value formulas>>). Here's a naive use of the cache:

<$doc.demo description="Naive solution" code="""<$list variable="category" filter="fields formulas">

!! <<category>>
<$list filter=":cache[all[shadows+tiddlers]removeprefix[$:/config/flibbles/graph/edges/]removeprefix<category>removeprefix[/]]"/>
""" />

This seems to list all of the edge types by category efficiently, but in reality, the cache cannot reuse its results, all all shadows+tiddlers in your wiki get iterated over //twice//. That's because in both loops, <<.value category>> is different, so the cache must generate results for each combination of changing variables (in this case, only <<.value category>>). Here is a better approach:

<$doc.demo description="Better solution" code="""<$list variable="category" filter="fields formulas">

!! <<category>>
<$list filter=":cache[all[shadows+tiddlers]removeprefix[$:/config/flibbles/graph/edges/]] +[removeprefix<category>removeprefix[/]]"/>
""" />

The results are the same, but here, we've moved the use of <<.value category>> to outside the cached filter run, so now the cache has the same variable context for both executions (in this case, no variables), and thus can reuse its results. All shadows+tiddlers get iterated over only once, and now only the much-smaller set of edge configuration tiddlers get iterated twice.

Always be aware of what variables are inside your cache runs, and which ones will be changing from invocation to invocation.

[[Cache Filter Run Prefix (Examples)]]
